<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
       "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>Axis2/C OM Tutorial</title>
  <meta name="generator" content="amaya 9.4, see http://www.w3.org/Amaya/" />
</head>

<body>
<h1>Axis2/C OM Tutorial</h1>

<h2>Content</h2>
<ul>
  <li><a href="#Introduction">Introduction</a>
    <ul>
      <li><a href="#What_is_OM">What is OM</a></li>
      <li><a href="#For_Whom_is_This_Tutorial">For Whom is This
      Tutorial</a></li>
      <li><a href="#What_is_Pull_Parsing">What is Pull Parsing</a></li>
      <li><a href="#Features_of_OM">Features of OM</a></li>
      <li><a href="#Where_Does_SOAP_Come_into_Play?">Where Does SOAP Come
        into Play?</a></li>
    </ul>
  </li>
  <li><a href="#Working_with_OM">Working with OM</a>
    <ul>
      <li><a href="#Creation">Creation</a></li>
      <li><a href="#Addition_and_Detaching_of_Nodes">Addition and Detaching
        of Nodes</a></li>
      <li><a href="#Traversing">Traversing</a></li>
    </ul>
  </li>
</ul>
<a id="Introduction"></a>

<h2>Introduction</h2>
<a id="What_is_OM"></a>

<h3>What is OM?</h3>

<p>OM stands for Object Model (a.k.a AXIOM - AXis Object Model) and refers to
the XML infoset model that is developed for Axis 2. XML infoset refers to the
information included inside the XML. For programmatical manipulation it is
convenient to have a representation of this XML infoset in a language
specific manner. DOM and JDOM are two such XML models. OM is conceptually
similar to such an XML model by its external behavior but deep down it is
very much different.</p>

<p>The objective of this tutorial is to introduce the basics of OM C and
explain best practices while using OM.</p>

<p>AXIOM C is a C implementation of AXIOM java. We have tried to get almost
the same kind of API in C.</p>
<a id="For_Whom_is_This_Tutorial"></a>

<h3>For whom is this Tutorial?</h3>

<p>This tutorial can be used by anybody who is interested and wants to go
deeper in to OM C. Knowledge in similar object models such as DOM will be
quite helpful in understanding OM but such knowledge is not assumed. Several
links are listed in the appendix/ links section that will help understand the
basics of XML.</p>
<a id="What_is_Pull_Parsing"></a>

<h3>What is Pull Parsing ?</h3>
Pull parsing is a new trend in XML processing. The previously popular XML
processing frameworks such as DOM were "push-based" which means the control
of the parsing was with the parser itself. This approach is fine and easy to
use but it is not efficient in handling large XML documents since a complete
memory model will be generated in the memory. Pull parsing inverts the
control and hence the parser only proceeds at the users command. The user can
decide to store or discard events generated from the parser. OM is based on
pull parsing. To learn more about XML pull parsing see the <a
href="http://www.bearcave.com/software/java/xml/xmlpull.html">XML pull
parsing introduction</a>. <a id="Features_of_OM"></a>

<h3>Features of OM</h3>

<p>OM is a lightweight, differed built XML info set representation based on
StAX API derived form (<a
href="http://www.jcp.org/aboutJava/communityprocess/first/jsr173/">JSR
173</a>), which is the standard streaming pull parser API. OM can be
manipulated as flexibly as any other object model (Such as <a
href="http://www.jdom.org/">JDOM</a>), but underneath the objects will be
created only when they are absolutely required. This leads to much less
memory intensive programming. Following is a short feature overview of OM.</p>
<ul>
  <li>Lightweight: OM is specifically targeted to be lightweight. This is
    achieved by reducing the depth of the hierarchy, number of methods and
    the attributes enclosed in the objects. This makes the objects less
    memory intensive.</li>
  <li>Differed building: By far this is the most important feature of OM. The
    objects are not made unless a need arises for them. This passes the
    control of building over to the object model itself rather than an
    external builder.</li>
  <li>Pull based: For a differed building mechanism a pull based parser is
    required. OM is based on StAX, the standard pull parser API.
    <p>Since different XML parsers offer different kinds of pull parser APIs
    we define an API derived from StAX. That API is defined in
    axis2_xml_reader.h , similarly we define an xml writer api in
    axis2_xml_writer.h. These two APIs work as an abstarction layer between
    any XML parser and OM. So any parser that is going to be used for OM
    should implement the axis2_xml_reader API and axis2_xml_writer API using
    a wrapper layer.</p>
    <p>Currenly we use Libxml2 as our default XML parser.</p>
  </li>
</ul>
<!-- Special section -->
<!--age -->

<p class="img"><img alt="" src="images/archi006.jpg" class="img" width="490"
height="282" /></p>
<!--  End of Image -->

<p>OM Builder wraps the raw xml character stream through the axis2_xml_reader
API. Hence the complexities of the pull event stream is covered</p>
<a id="Where_Does_SOAP_Come_into_Play?"></a>

<h3>Where Does SOAP Come into Play?</h3>

<p>In a nutshell SOAP is a information exchange protocol based on XML. SOAP
has a defined set of XML elements that should be used in messages. Since Axis
is a "SOAP Engine" and OM is built for Axis, A SOAP specific API was
implemented on top of OM.We have defined a number of structs to represent
SOAP constructs like Envelope etc.. These structs wraps general OM
structures. See <a
href="http://www.w3schools.com/SOAP/soap_intro.asp">here</a> to learn more
about SOAP.</p>
<!--<p>This abstraction provides</p>
<ul>
<li>differed building support</li>
<li>Caching</li>
</ul>
<p>AXIOM has the flexibility to plug in any builder which implements the given builders interface.  The upcoming sections of this tutorial deal with the creation and usage of OM for manipulating SOAP (and to some extent nonSOAP) based XML documents.</p>
-->
<a id="Working_with_OM"></a>

<h2>Working with OM</h2>
<a id="Creation">Axis2c environment</a>

<p>Before starting the discussion on om, it is necessary to get a good
understanding of the basics of axis2c. Axis2c is designed to be plugble to
any system written in C or C++ and therefore axis2 has abstracted the
functionalities that differ from system to system in to a structure
"axis2_env_t" which we refer to as axis2 environment . The environment holds
axis2_allocater_t [ used for memory allocation/deallocation ] , axis2_error_t
[ error reporting mechanism ] axis2_log_t [ logging mechanism ] and
axis2_thread_t [threading mechnism ]. axis2_allocator_t has function pointers
to malloc, realloc and free functions and all memory allocation and
deallocation is done using the allocator. So by pluging in a different
allocator, a user can make the entire Axis2 system to use different memory
management functions.</p>

<p>How to create the axis2 environment</p>

<p><b>creating the allocator</b></p>

<p>axis2_allocator_t *allocator = NULL;</p>

<p>allocator = axis2_allocator_init(NULL);</p>

<p></p>

<p>We parse NULL to the above function to use the default allocator. Then the
allocators function pointers point to malloc, realloc and free functons. If
you have your own allocator structure, you may pass it instead.</p>

<p>Convinent macros are defined to use allocator functions as follows (refer
to axis2_allocator.h for more information).</p>

<p>AXIS2_MALLOC , AXIS2_REALLOC and AXIS2_FREE .</p>

<p>In a similar fashion, you can create the error and log structures.</p>

<p>axis2_log_t *log = NULL;</p>

<p>axis2_error_t *error = NULL;</p>

<p>log = axis2_log_create(allocator, NULL, NULL);</p>

<p>log = axis2_log_create(allocator, NULL, "mylog.log");</p>

<p>Now we can create the environment by parsing the allocator, error and log
to axis2_env_create_with_error_log() function.</p>

<p>axis2_env_t *env = NULL;</p>

<p>env = axis2_env_create_with_error_log(allocator, error, log);</p>

<p></p>

<p>Apart from the above abstraction , all other library functions used are
ANSI C complient. Further, platform dependent funtions are also
abstracted.</p>

<p>As a rule of thumb, all "create" functions take a double pointer to the
environment as its first argument and all other functions take pointer to
'this' struct as the first argument and a double pointer to environment as
the second argument. (Please refer to our coding convention page to learn
more about this)</p>

<p>eg.</p>

<p>axiom_node_t *node = NULL;</p>

<p>axiom_node_t *child = NULL;</p>

<p>node = axiom_node_create(env);</p>

<p>Note that 'env' is a double pointer to the environment struct.</p>

<p>child = AXIOM_NODE_GET_FIRST_CHILD(node, env);</p>

<p>Note that we are parsing the node (pointer to om_node_t ) as the first
argument and double pointer to environment.</p>

<p></p>

<p>All functions return a pointer to a struct or a status code [
AXIS2_SUCCESS , AXIS2_FAILURE]. So if NULL is returned by a function</p>

<p>it is either because there is nothing to return or an error has
occured.</p>

<h3>Creation</h3>

<p>Creation is the first and foremost action when using an Object
representation. This part explains how OM can be built from either an
existing document or programmatically. OM provides a notion of a builder to
create objects. Since OM is tightly bound to StAX, a StAX compliant reader
should be created first with the desired input stream.</p>

<p>In our OM implementation we define a struct 'axiom_node_t' which acts
as the container of the other structs and it maintains the links that form
the Link List OM in C.</p>

<p>So to traverse the structure the functions defined in axiom_node.h must
be used. To access xml information, the 'data element' struct stored in
axiom_node_t must be obtained using the AXIOM_NODE_GET_DATA_ELEMENT
macro. The type of the struct stored in the 'axiom_node_t' struct can be
obtained by AXIOM_NODE_GET_NODE_TYPE macro. When we create
axiom_element_t , axiom_text_t etc .., it is required to parse a double
pointer to the node struct as the last parameter of the create function so
that the correponding node struct can be referenced using that pointer.</p>

<p>Ex.</p>

<p>axiom_node_t *my_node = NULL;</p>

<p>axiom_element_t *my_ele = NULL;</p>

<p>my_ele = axiom_element_create(env, NULL, "MY_ELEMENT", NULL,
&amp;my_node);</p>

<p>Now if we call AXIOM_NODE_GET_NODE_TYPE macro on 'my_node' pointer we
will get the value as AXIOM_ELEMENT .</p>

<div>
<p><b>Code Listing 1</b></p>
</div>
<pre>axis2_xml_reader_t *xml_reader = NULL;<br />
axiom_stax_builder_t *om_builder = NULL;<br />
axiom_soap_builder_t *soap_builder = NULL;<br />
axiom_soap_envelope_t *soap_envelope = NULL;<br />
<i>/** create the parser */</i><br />
axis2_xml_reader_t *xml_reader = axis2_xml_reader_create_for_file(env, "test_soap.xml",NULL);<br />
<i>/** create the OM builder */</i><br />
om_builder = axiom_stax_builder_create(env, xml_reader);<br />
<i>/** create SOAP builder */</i><br />
soap_builder = axiom_soap_builder_create(env, om_builder , AXIOM_SOAP_ENVELOPE_NAMESPACE_URI);<br />
<i>/** get soap envelope */</i><br />
soap_envelope = AXIOM_SOAP_BUILDER_GET_SOAP_ENVELOPE(soap_builder, env);<br /></pre>
<br />


<p>As the example shows, creating an OM from xml_reader is pretty straight
forward. However elements and nodes can be created programmatically to modify
the structure as well. Currently OM has two builders, namely the
axiom_stax_builder_t and the axiom_soap_builder_t. These builders provide
the necessary information to the XML info set model to build itself.</p>

<div>
<p><b>Code Listing 2</b></p>
</div>

<p class="img-title"><b></b></p>
<pre class="code">axiom_namespace_t *ns1 = NULL;
axiom_namespace_t *ns2 = NULL;

axiom_element_t* root_ele = NULL;
axiom_node_t*    root_ele_node = NULL;

axiom_element_t *ele1      = NULL;
axiom_node_t *ele1_node = NULL;

ns1 = axiom_namespace_create(env, "bar", "x");
ns2 = axiom_namespace_create(env, "bar1", "y");


root_ele = axiom_element_create(env, NULL, "root", ns1, &amp;root_ele_node);
ele1     = axiom_element_create(env, root_node, "foo1", ns2, &amp;ele1_node);</pre>

<p>Several differences exist between a programmatically created
axiom_node_t and a conventionally built axiom_node_t. The most
important difference is that the latter will have a pointer to its builder,
where as the former does not have that information. As stated earlier in this
tutorial, since the OM is built as and when required, each and every
axiom_node_t struct should have a reference to its builder. If this
information is not available, it is due to the struct being created without a
builder.</p>

<p></p>

<p>The SOAP struct hierarchy is made in the most natural way for a
programmer. It acts as a wrapper layer on top of OM implementation. The SOAP
structs wraps the correspoding om_node_t structs to store information in
xml.</p>
<!--  The following illustration of the actual class diagram will be helpful in understanding this.
Need an image here -->
<a id="Addition_and_Detaching_of_Nodes"></a>

<h3>Addition and Detaching of Nodes</h3>

<p>Addition and removal methods are defined in the axiom_node.h header.
The following are the most important in adding nodes.</p>

<div>
<p><b>Code Listing 3</b></p>
</div>

<p>Add child operation</p>
<pre class="code">axis2_status_t
axiom_node_add_child( axiom_node_t *om_node,  
                         axis2_env_t **env, 
                         axiom_node_t *child_node);</pre>

<p>Detach operation</p>
<pre class="code">axiom_node_t*
axiom_node_detach (axiom_node_t *om_node, 
                      axis2_env_t **env);</pre>

<p>The detach operation resets the links and remove a node from om
structure.</p>

<p></p>

<p>This code segment shows how the addition takes place. Note that it is
related to the code segment shown in the creation section.</p>

<div>
<p><b>Code Listing 4</b></p>
</div>
<pre class="code">axiom_node_t *foo_node = NULL;
axiom_element_t *foo_ele = NULL;
axiom_node_t *bar_node = NULL;
axiom_element_t *bar_ele = NULL;

foo_ele = axiom_element_create(env, NULL, "FOO", NULL, &amp;foo_node);
bar_ele = axiom_element_create(env, NULL, "BAR", NULL. &amp;bar_node); </pre>

<p>Now if we want to make 'BAR' element, a child of 'FOO' element we can use
add_child MACRO.</p>
<pre class="code"> AXIOM_NODE_ADD_CHILD(foo_node, env, bar_node); </pre>

<p>Or we can parse the foo_node as the parent node at the time of creating to
bar_ele as follows.</p>
<pre> bar_ele = axiom_element_create(env, foo_node, "BAR", NULL, &amp;bar_node);</pre>
<ul>
  <li>add_child function will always add the child as the first child of the
    parent.</li>
  <li><p>A given node can be removed from the tree by calling the detach()
    method. A node can also be removed from the tree by calling the remove
    method of the returned iterator which will also call the detach method of
    the particular node internally.</p>
  </li>
  <li>Namespaces are a tricky part of any XML object model and is the same in
    OM. However the interface to the namespace have been made very simple.
    axiom_namespace_t * is the struct that represents a namespace and we
    do not have setter functions. This makes the axiom_namespace
  immutable.</li>
</ul>

<p>Following are the important methods available in axiom_element to
handle namespaces.</p>

<div>
<p><b>Code Listing 5</b></p>
</div>
<pre class="code">axiom_namespace_t* 
axiom_element_declare_namespace(axiom_element_t *om_ele,  
                                   axis2_env_t **env, 
                                   axiom_node_t *om_node, 
                                   axiom_namespace_t *om_ns);

axiom_namespace_t* 
axiom_element_find_namespace(axiom_element_t *om_ele,
                                axis2_env_t **env, 
                                axiom_node_t *om_node, 
                                axis2_char_t *uri, 
                                axis2_char_t *prefix);

axiom_namespace_t*
axiom_element_find_declared_namespace(axiom_element_t *om_element,
                                         axis2_env_t **env,
                                         axis2_char_t *uri,
                                         axis2_char_t *prefix);

axis2_status_t
axiom_element_set_namespace(axiom_element_t *om_element,
                               axis2_env_t **env,
                               axis2_namespace_t *ns,
                               axiom_node_t *element_node);</pre>

<p>An om_element has a namespace list [declared namespaces] and a pointer to
its own namespace if one exists.</p>

<p>The declare_namespace function is straight forward. It adds a namespace to
namespace declarations section. Note that a namespace declaration that is
already added will not be added twice.</p>

<p>find_namespace is a very handy method to locate a namespace higher up the
tree. It searches for a matching namespace in its own declarations section
and jumps to the parent if it's not found. The search progresses up the tree
until a matching namespace is found or the root has been reached.</p>

<p>find_declared_namespace can be used to search for a namespace in the
current element's namespace declarations section.</p>

<p>set_namespace an om_elements own namespace , [ Note that an element's own
namespace should be declared in its own namespace declarations section or its
one of its parent element. ] This method first searches for a matching
namespace using find_namespace and if a matching namespace is not found
anamespace is declared to this om_element's namespace declarations section
before seting the own namespace reference.</p>

<p>The following simple code segment shows how the namespaces are dealt with
in OM</p>

<div>
<p><b>Code Listing 6</b></p>
</div>
<pre class="code">axiom_namespace_t *ns1 = NULL;
axiom_namespace_t *ns2 = NULL;
axiom_namespace_t *ns3 = NULL;

axiom_node_t *root_node = NULL;
axiom_element_t *root_ele = NULL;

axiom_node_t *ele1_node = NULL;
axiom_element_t *ele1   = NULL;

axiom_node_t *text_node = NULL;
axiom_text_t *om_text   = NULL;

ns1 = axiom_namespace_create(env, "bar", "x");
ns2 = axiom_namespace_create(env, "bar1", "y");

root_ele = axiom_element_create(env, NULL , "root", ns1, &amp;root_node);
ele1     = axiom_element_create(env, root_node, "foo", ns2, &amp;ele1_node);
om_text  = axiom_text_create(env, ele1_node, "blah", &amp;text_node);</pre>

<p>Serilization of the root element produces the following XML</p>
<pre class="xml">&lt;x:root xmlns:x="bar"&gt;
  &lt;y:foo xmlns:y="bar1"&gt;
        blah
  &lt;/y:foo&gt;
&lt;/x:root&gt;</pre>
<a id="Traversing"></a>

<p>if we want to produce</p>
<pre class="xml">&lt;x:foo xmlns:x="bar" xmlns:y="bar1"&gt;Test&lt;/x:foo&gt;</pre>

<p>we can use set_namespace and declare namespace functions as follows</p>
<pre class="code">axiom_node_t *foo_node = NULL;
axiom_element_t *foo_ele  = NULL;
axiom_namespace_t *ns1 = NULL;
axiom_namespace_t *ns2 = NULL;

foo_ele = axiom_element_create(env, NULL,"foo" ,NULL, &amp;foo_node);

ns1 = axiom_namespace_create(env, "bar", "x");

ns2 = axiom_namespace_create(env, "bar1","y");

AXIOM_ELEMENT_SET_NAMESPACE(foo_ele, env, ns1, foo_node);

AXIOM_ELEMENT_DECLARE_NAMESPACE(foo_ele, env, ns2, foo_node);

AXIOM_ELEMENT_SET_TEXT(foo_ele, env, "Test", &amp;foo_node);</pre>

<h3>Traversing</h3>

<p>Traversing the OM structure can be done by obtaining an iterator struct.
You can either call the appropriate function on OM element or create the
iterator manually. OM C offers three iterators to traverse the OM structure.
They are</p>
<ul>
  <li>axiom_children_iterator_t</li>
  <li>axiom_child_element_iterator_t</li>
  <li>axiom_children_qname_iterator_t</li>
</ul>

<p>The Iterator supports the 'OM way' of accessing elements and is more
convenient than a list for sequential access. The following code sample shows
how the children can be accessed. The children can be of type AXIOM_TEXT
or AXIOM_ELEMENT.</p>

<div>
<p><b>Code Listing 7</b></p>
</div>
<pre class="code">axiom_children_iterator_t *children_iter = NULL;
children_iter = AXIOM_ELEMENT_GET_CHILDREN(om_ele, env, om_node);
if(NULL != children_iter )
{
    while(AXIOM_CHILDREN_ITERATOR_HAS_NEXT(children_iter, env))
    {
        axiom_node_t *node = NULL;
        node = AXIOM_CHILDREN_ITERATOR_NEXT(children_iter, env);
        if(NULL != node)
        {
           if(AXIOM_NODE_GET_NODE_TYPE(node, env) == AXIOM_ELEMENT)
           {
               /** any processing */
           }
        } 

    }
}</pre>

<p>Apart from this, every axiom_node_t struct has links to its siblings.
If a thorough navigation is needed the AXIOM_NODE_GET_NEXT_SIBLING() and
AXIOM_NODE_GET_PREVIOUS_SIBLING() macros can be used. A restrictive set
can be chosen by using AXIOM_ELEMENT_XXX_WITH_QNAME() methods. The
AXIOM_ELEMENT_GET_FIRST_CHILD_WITH_QNAME() method returns the first child
that matches the given axis2_qname_t and
AXIOM_ELEMENT_GET_CHILDREN_WITH_QNAME() returns
axiom_children_qname_iterator_t which can be used to travese all the
matching children. The advantage of these iterators are that they won't build
the whole object structure at once; it builds only what is required.</p>
<!-- Special section -->

<table width="100%">
  <tbody>
    <tr>
      <td><img src="images/OM005.gif" alt="" width="35" height="57" /></td>
      <td class="special-td">All iterator implementations internally stay one
        step ahead of their apparent location to provide the correct value
        for the HAS_NEXT() function . This hidden advancement can build
        elements that are not intended to be built at all.</td>
      <td></td>
    </tr>
  </tbody>
</table>
<!-- End of special section -->

<p><b>Serialization</b></p>

<p>OM can be serialized using AXIOM_NODE_SERIALIZE macro .The
serialization uses axis2_xml_writer.h and axiom_output.h APIs.</p>

<p>Here is an example that shows how to write the output to the console, (We
serialize the SOAP envelope created in code listing 1).</p>

<div>
<p><b>Code Listing 8</b></p>
</div>
<pre class="code">axis2_xml_writer_t *xml_writer = NULL;
axiom_output_t *om_output = NULL;
axis2_char_t *buffer = NULL;

..............

xml_writer = axis2_xml_writer_create(env, NULL, 0, 0);
om_output = axiom_output_create(env, xml_writer);

AXIOM_SOAP_ENVELOPE_SERIALIZE(envelope, env, om_output);
buffer = (axis2_char_t*)AXIS2_XML_WRITER_GET_XML(xml_writer, env);
printf("%s ", buffer);</pre>

<p>An easy way to serialize is to use the to_string function in om_element</p>

<p><b>Code Listing 9</b></p>
<pre class="code">axis2_char_t *xml_output = NULL; 
axiom_node_t *foo_node = NULL;
axiom_element_t *foo_ele = NULL;
axiom_namespace_t* ns = NULL;

ns = axiom_namespace_create(env, "bar","x");

foo_ele = axiom_element_create(env, NULL, "foo", ns, &amp;foo_node);

AXIOM_ELEMENT_SET_TEXT(foo_ele, env, "EASY SERAILIZATION", foo_node);

xml_output = AXIOM_ELEMENT_TO_STRING(foo_ele, env, foo_node);

printf("%s", xml_output);
AXIS2_FREE((*env)-&gt;allocator, xml_output);</pre>

<p>Note that freing the returned buffer is users responsibility</p>

<p></p>

<p><b>Using axis2_xml_reader and axis2_xml_writer</b></p>

<p>axis2_xml_reader provides three create functions that and can be used for
different xml input sources.</p>

<p>axis2_xml_reader_create_for_file() functon can be used to read from a
file.</p>

<p>axis2_xml_reader_create_for_io uses a user defined callback function to
pull xml.</p>

<p>axis2_xml_reader_create_for_memory can be used to read from an xml string
that is in a character buffer.</p>

<p>Similarly xml_writer provides two create functions,</p>

<p>axis2_xml_writer_create_for_file can be used to write to a file.</p>

<p>axis2_xml_writer_create_for_memory can be used to write to an internal
memory buffer and obtain the xml string to a charcater buffer as</p>

<p>the output. Please refer to axis2_xml_reader.h and axis2_xml_writer.h for
more information.</p>

<p><b>How to avoid memory leaks and double frees when using om</b></p>

<p>You have to be extremly carefull when using om in order to avoid memory
leaks and double free errors. Following guide lines will be very useful.</p>

<p>1. om_element_t struct keeps a list of attributes and a list of
namespaces, when a namespace pointer is added to this list , it will be freed
when this om_element is freed, Therefore same pointer to a namespace or an
attribute should not be passed twice to a create , add or set function.</p>

<p>To avoid the inconvenience, clone functions have been implemented for both
axiom_namespace and axiom_attribute structures.</p>

<p>2. OM returns shallow references to its string values , Therefore when
using the returned values , AXIS2_STRDUP () function should be used</p>

<p>if the returned value is going to be set to another struct to avoid double
free errors.</p>

<p>Example:</p>

<p>axiom_namespace_t *ns = NULL;</p>

<p>axis2_char_t *uri = NULL;</p>

<p>ns = axiom_namespace_create(env, "http://ws.apache.org", "om");</p>

<p>uri = AXIOM_NAMESPACE_GET_URI(ns, env);</p>

<p>/** now uri points to the same place where namespace structs uri pointer
is pointing */</p>

<p>Therefore following will cause a double free */</p>

<p>AXIS2_FREE((*env)-&gt;allocator, uri);</p>

<p>AXIOM_NAMESPACE_FREE(ns, env);</p>

<p>3. when creating om programatically , if you are declaring a namespace to
an om elment it is advisible to find whether the namespace is already
availble in the elements scope, using find_namespace function; if available,
that pointer can be used instead of creating another namespace struct
instance to prevent memory leaks.</p>

<p><b>Complete code for the OM based document building and
serialization</b></p>

<p>The following code segment shows how to use the OM for completely building
a document and then serializing it into text pushing the output to the
console.</p>

<div>
<p><b>Code Listing 10</b></p>

<p></p>
</div>
<pre>#include &lt;axiom_node.h&gt;
#include &lt;axis2.h&gt;
#include &lt;axis2_env.h&gt;
#include &lt;axiom_element.h&gt;
#include &lt;axiom_document.h&gt;
#include &lt;axiom_stax_builder.h&gt;
#include &lt;axis2_xml_reader.h&gt;
#include &lt;axis2_log_default.h&gt;
#include &lt;axis2_error_default.h&gt;
#include &lt;axis2_xml_writer.h&gt;
#include &lt;axiom_output.h&gt;
#include &lt;stdio.h&gt;


FILE *f = NULL;
int read_input_callback(char *buffer, int size, void* ctx)

{
    <b>return</b> fread(buffer, <b>sizeof</b>(char), size, f);
}
int close_input_callback(void *ctx)
{
    <b>return</b> fclose(f);
}

axis2_env_t * create_environment()

{
    axis2_allocator_t *allocator = NULL;
    axis2_env_t *env = NULL;
    axis2_log_t *log = NULL;

    axis2_error_t *error = NULL;
    allocator = axis2_allocator_init(NULL);
    log = axis2_log_create(allocator, NULL, NULL);

    error = axis2_error_create(allocator);
    env = axis2_env_create_with_error_log(allocator, error, log);
    <b>return</b> env;
}

build_and_serialize_om(axis2_env_t **env)
{
    axiom_node_t *root_node = NULL;

    axiom_element_t *root_ele = NULL;
    axiom_document_t *document = NULL;
    axiom_stax_builder_t *om_builder = NULL;

    axis2_xml_reader_t *xml_reader = NULL;
    axis2_xml_writer_t *xml_writer = NULL;
    axiom_output_t *om_output = NULL;

    axis2_char_t *buffer = NULL;
    
    f = fopen("test.xml","r");
    xml_reader = axis2_xml_reader_create_for_io(env, read_input_callback,
                                                    close_input_callback, NULL, NULL);
    <b>if</b>(!xml_reader)
        <b>return</b> -1;

    om_builder = axiom_stax_builder_create(env, xml_reader);
    <b>if</b>(!om_builder)
    {
        AXIS2_XML_READER_FREE(xml_reader, env);
        <b>return</b> AXIS2_FAILURE;
    }
    document = AXIOM_STAX_BUILDER_GET_DOCUMENT(om_builder, env);
    <b>if</b>(!document)
    {
        AXIOM_STAX_BUILDER_FREE(om_builder, env);
        <b>return</b> AXIS2_FAILURE;
    }
    
    root_node = AXIOM_DOCUMENT_GET_ROOT_ELEMENT(document, env);
    <b>if</b>(!root_node)
    {
        AXIOM_STAX_BUILDER_FREE(om_builder, env);
        <b>return</b> AXIS2_FAILURE;
    }        
    <b>if</b>(root_node)
    {
        <b>if</b>(AXIOM_NODE_GET_NODE_TYPE(root_node, env) == AXIOM_ELEMENT)
        {
            root_ele = (axiom_element_t*)AXIOM_NODE_GET_DATA_ELEMENT (root_node, env);
            <b>if</b>(root_ele)
            {
                printf(" %s" , AXIOM_ELEMENT_GET_LOCALNAME(root_ele, env));
            }
        }
    }
    AXIOM_DOCUMENT_BUILD_ALL(document, env);
    
    xml_writer = axis2_xml_writer_create_for_memory(env, NULL, AXIS2_TRUE, 0, AXIS2_XML_PARSER_TYPE_BUFFER);
    
    om_output = axiom_output_create(env, xml_writer);
    
    AXIOM_NODE_SERIALIZE(root_node, env, om_output);
    buffer = (axis2_char_t*)AXIS2_XML_WRITER_GET_XML(xml_writer, env);

    printf("The output XML is -&gt;&gt;&gt;&gt;\n %s ", buffer);

    
    <i>/** when om_output is freed xml_writer is also freed */</i>
    
    AXIOM_OUTPUT_FREE(om_output, env);
    
    <i>/** when om_builder is freed , the builder, om_document and the entire om structure is freed */</i>
    AXIOM_STAX_BUILDER_FREE(om_builder, env);
    
    AXIS2_FREE((*env)-&gt;allocator, buffer);
    
    <b>return</b> AXIS2_SUCCESS;
    
}
int main()
{
    int status = AXIS2_SUCCESS;
    
    axis2_env_t *env = NULL;
    axis2_allocator_t *allocator = NULL;
    env = create_environment();
<br />
    status = build_and_serialize_om(&amp;env);

    <b>if</b>(status == AXIS2_FAILURE)
    {
        printf(" build om failed");
    }
    
    axis2_env_free(env);
    
    <b>return</b> 0;
}</pre>
</body>
</html>
