<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
      "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>Axis2/C OM Tutorial</title>
  <meta name="generator" content="amaya 9.2.1, see http://www.w3.org/Amaya/"
  />
</head>
<body>
<h1>Axis2/C OM Tutorial</h1>
<h2>Content</h2>
<ul>
<li> <a href="#Introduction"> Introduction </a></li>
     <ul>
     <li> <a href="#What_is_OM"> What is OM </a></li>   
     <li> <a href="#For_Whom_is_This_Tutorial"> For Whom is This Tutorial </a> </li>
     <li> <a href="#What_is_Pull_Parsing"> What is Pull Parsing </a> </li>      
     <li> <a href="#Features_of_OM"> Features of OM</a> </li>
     <li> <a href="#Where_Does_SOAP_Come_into_Play?"> Where Does SOAP Come into Play? </a> </li>
     </ul>
<li> <a href="#Working_with_OM"> Working with OM </a> </li>
     <ul>
     <li> <a href="#Creation"> Creation </a> </li>
     <li> <a href="#Addition_and_Detaching_of_Nodes"> Addition and Detaching of Nodes </a> </li>
     <li> <a href="#Traversing"> Traversing </a> </li>
     </ul>
 </ul>


<a name="Introduction"> </a><h2>Introduction</h2>

<a name="What_is_OM"> </a><h3>What is OM?</h3>

<p>OM stands for Object Model (a.k.a AXIOM - AXis Object Model) and
refers to the XML infoset model that is developed for Axis 2. XML infoset
refers to the information included inside the XML. For programmatical
manipulation it is convenient to have a representation of this XML infoset in
a language specific manner. DOM and JDOM are two such XML models. OM is
conceptually similar to such an XML model by its external behavior but deep
down it is very much different.</p>

<p>The objective of this tutorial is to introduce the basics of OM C and
explain best practices while using OM.</p>

<p>AXIOM C is a C implementation of AXIOM java. We have tried to get almost
the same kind of API in C.</p>

<a name="For_Whom_is_This_Tutorial"> </a><h3>For whom is this Tutorial?</h3>

<p>This tutorial can be used by anybody who is interested and wants to go deeper in to OM C.
Knowledge in similar object models such as DOM will be quite
helpful in understanding OM but such knowledge is not assumed. Several links
are listed in the appendix/ links section that will help understand the
basics of XML.</p>

<a name="What_is_Pull_Parsing"> </a><h3>What is Pull Parsing ?</h3>
Pull parsing is a new trend in XML processing. The previously popular XML
processing frameworks such as SAX and DOM were "push-based" which means the
control of the parsing was with the parser itself. This approach is fine and
easy to use but it is not efficient in handling large XML documents since a
complete memory model will be generated in the memory. Pull parsing inverts
the control and hence the parser only proceeds at the users command. The user
can decide to store or discard events generated from the parser. OM is based
on pull parsing. To learn more about XML pull parsing see the <a
href="http://www.bearcave.com/software/java/xml/xmlpull.html" target="_blank">XML pull
parsing introduction</a>.

<a name="Features_of_OM"> </a><h3>Features of OM</h3>

<p>OM is a lightweight, differed built XML info set representation based on
StAX API derived form (<a
href="http://www.jcp.org/aboutJava/communityprocess/first/jsr173/" target="_blank">JSR
173</a>), which is the standard streaming pull parser API. OM can be
manipulated as flexibly as any other object model (Such as <a
href="http://www.jdom.org/" target="_blank">JDOM</a>), but underneath the objects will be
created only when they are absolutely required. This leads to much less
memory intensive programming. Following is a short feature overview of OM.</p>
<ul>
  <li>Lightweight: OM is specifically targeted to be lightweight. This is
    achieved by reducing the depth of the hierarchy, number of methods and
    the attributes enclosed in the objects. This makes the objects less
    memory intensive.</li>
  <li>Differed building: By far this is the most important feature of OM. The
    objects are not made unless a need arises for them. This passes the
    control of building over to the object model itself rather than an
    external builder.</li>
  <li>Pull based: For a differed building mechanism a pull based parser is
    required. OM is based on StAX, the standard pull parser API.
    <p>Since different XML parsers offer different kinds of pull parser APIs
    we define an API derived from StAX. That API is defined in
    axis2_xml_reader.h , similarly we define an xml writer api in
    axis2_xml_writer.h. These two APIs work as an abstarction layer between
    any XML parser and OM. So any parser that is going to be used for OM should
    implement the axis2_xml_reader API and axis2_xml_writer API using a
    wrapper layer.</p>
    <p>Currenly we use Libxml2 as our default XML parser.</p>
  </li>
</ul>
<!-- Special section -->
<!--age -->

<p align="center" class="img"><img alt="" src="images/archi006.jpg"
class="img" width="490" height="282"></p>
<!--  End of Image -->

<p>OM Builder wraps the raw xml character stream through the axis2_xml_reader
API. Hence the complexities of the pull event stream is covered</p>

<a name="Where_Does_SOAP_Come_into_Play?"> </a><h3>Where Does SOAP Come into Play?</h3>

<p>In a nutshell SOAP is a information exchange protocol based on XML. SOAP
has a defined set of XML elements that should be used in messages. Since Axis
is a "SOAP Engine" and OM is built for Axis, A SOAP specific API was
implemented on top of OM.We have defined a number of structs to represent SOAP
constructs like Envelope etc.. These structs wraps general OM structures. See
<a href="http://www.w3schools.com/SOAP/soap_intro.asp" target="_blank"> here </a> to learn
more about SOAP.</p>
<!--<p>This abstraction provides</p>
<ul>
<li>differed building support</li>
<li>Caching</li>
</ul>
<p>AXIOM has the flexibility to plug in any builder which implements the given builders interface.  The upcoming sections of this tutorial deal with the creation and usage of OM for manipulating SOAP (and to some extent nonSOAP) based XML documents.</p>
-->

<a name="Working_with_OM"> </a><h2>Working with OM</h2>

<a name="Creation"> </a><h3>Creation</h3>

<p>Creation is the first and foremost action when using an Object
representation. This part explains how OM can be built from either an existing
document or programmatically. OM provides a notion of a builder to
create objects. Since OM is tightly bound to StAX, a StAX compliant reader
should be created first with the desired input stream. </p>

<p>In our OM implementation we define a struct 'axis2_om_node_t' which acts as
the container of the other structs and it maintains the links that form the
Link List OM in C.</p>

<p>So to traverse the structure the functions defined in axis2_om_node.h must
be used. To access xml information, the 'data element' struct stored in
axis2_om_node_t must be obtained using the AXIS2_OM_NODE_GET_DATA_ELEMENT
macro. The type of the struct stored in the 'axis2_om_node_t' struct can be
obtained by AXIS2_OM_NODE_GET_NODE_TYPE macro. When we create
axis2_om_element_t , axis2_om_text_t etc .., it is required to parse a double
pointer to the node struct as the last parameter of the create function so
that the correponding node struct can be referenced using that pointer.</p>

<p>Ex.</p>

<p>axis2_om_node_t *my_node = NULL;</p>

<p>axis2_om_element_t *my_ele = NULL;</p>

<p>my_ele = axis2_om_element_create(env, NULL, "MY_ELEMENT", NULL,
&amp;my_node);</p>

<p>Now if we call AXIS2_OM_NODE_GET_NODE_TYPE macro on 'my_node' pointer we
will get the value as AXIS2_OM_ELEMENT .</p>

<div align="left">
<p><b>Code Listing 1</b></p>
</div>
<source><pre>axis2_xml_reader_t *xml_reader = NULL;
axis2_om_stax_builder_t *om_builder = NULL;
axis2_soap_builder_t *soap_builder = NULL;
axis2_soap_envelope_t *soap_envelope = NULL;


/** create the parser */<br>
axis2_xml_reader_t *xml_reader = axis2_xml_reader_create_for_file(env, "test_soap.xml",NULL);

/** create the OM builder */

om_builder = axis2_om_stax_builder_create(env, xml_reader);

/** create SOAP builder */

soap_builder = axis2_soap_builder_create(env, om_builder , AXIS2_SOAP_ENVELOPE_NAMESPACE_URI);

/** get soap envelope */
soap_envelope = AXIS2_SOAP_BUILDER_GET_SOAP_ENVELOPE(soap_builder, env);</pre>
</source>

<br>
<p>
As the example shows, creating an OM from xml_reader is pretty
straight forward. However elements and nodes can be created programmatically
to modify the structure as well. Currently OM has two builders, namely the
axis2_om_stax_builder_t and the axis2_soap_builder_t. These builders provide
the necessary information to the XML info set model to build itself. </p>

<div align="left">
<p><b>Code Listing 2</b></p>
</div>

<p class="img-title"><b></b></p>
<pre class="code">axis2_om_namespace_t *ns1 = NULL;
axis2_om_namespace_t *ns2 = NULL;

axis2_om_element_t* root_ele = NULL;
axis2_om_node_t*    root_ele_node = NULL;

axis2_om_element_t *ele1      = NULL;
axis2_om_node_t *ele1_node = NULL;

ns1 = axis2_om_namespace_create(env, "bar", "x");
ns2 = axis2_om_namespace_create(env, "bar1", "y");


root_ele = axis2_om_element_create(env, NULL, "root", ns1, &amp;root_ele_node);
ele1_node     = axis2_om_element_create(env, root_node, "foo1", ns2, &amp;ele1_node);</pre>

<p>Several differences exist between a programmatically created
axis2_om_node_t and a conventionally built axis2_om_node_t. The most
important difference is that the latter will have a pointer to its builder,
where as the former does not have that information. As stated earlier in
this tutorial, since the OM is built as and when required, each and every
axis2_om_node_t struct should have a reference to its builder. If this
information is not available, it is due to the struct being created without a
builder.</p>

<p></p>

<p>The SOAP struct hierarchy is made in the most natural way for a
programmer. It acts as a wrapper layer on top of OM implementation. The SOAP
structs wraps the correspoding om_node_t structs to store information in xml.</p>
<!--  The following illustration of the actual class diagram will be helpful in understanding this.
Need an image here -->

<a name="Addition_and_Detaching_of_Nodes"> </a><h3>Addition and Detaching of Nodes</h3>

<p>Addition and removal methods are defined in the axis2_om_node.h header.
The following are the most important in adding nodes.</p>

<div align="left">
<p><b>Code Listing 3</b></p>
</div>

<p>Add child operation</p>

<pre class="code">axis2_status_t
axis2_om_node_add_child( axis2_om_node_t *om_node,
axis2_env_t **env, axis2_om_node_t *child_node);
</pre>

<p>Detach operation</p>

<pre class="code">axis2_om_node_t*
axis2_om_node_detach (axis2_om_node_t *om_node,
axis2_env_t **env);</pre>

<p>The detach operation resets the links and remove a node from om
structure.</p>

<p></p>

<p>This code segment shows how the addition takes place. Note that it is
related to the code segment shown in the creation section.</p>

<div align="left">
<p><b>Code Listing 4</b></p>
</div>
<pre class="code">axis2_om_node_t *foo_node = NULL;
axis2_om_element_t *foo_ele = NULL;
axis2_om_node_t *bar_node = NULL;
axis2_om_element_t *bar_ele = NULL;

foo_ele = axis2_om_element_create(env, NULL, "FOO", NULL, &amp;foo_node);
bar_ele = axis2_om_element_create(env, NULL, "BAR", NULL. &amp;bar_node); </pre>

<p> Now if we want to make 'BAR' element, a child of 'FOO' element we can use add_child MACRO. </p>

<pre class="code"> AXIS2_OM_NODE_ADD_CHILD(foo_node, env, bar_node); </pre>

<p> Or we can parse the foo_node as the parent node at the time of creating to bar_ele as follows. </p>

<pre class"code"> bar_ele = axis2_om_element_create(env, foo_node, "BAR", NULL, &amp;bar_node);</pre>
<ul>
  <li>add_child function will always add the child as the first child of the
    parent.</li>
  <li><p>A given node can be removed from the tree by calling the detach()
    method. A node can also be removed from the tree by calling the remove
    method of the returned iterator which will also call the detach method of
    the particular node internally.</p>
  </li>
  <li>Namespaces are a tricky part of any XML object model and is the same in
    OM. However the interface to the namespace have been made very simple.
    axis2_om_namespace_t * is the struct that represents a namespace and we
    do not have setter functions. This makes the axis2_om_namespace
  immutable.</li>
</ul>

<p>Following are the important methods available in axis2_om_element to
handle namespaces.</p>

<div align="left">
<p><b>Code Listing 5</b></p>
</div>
<pre class="code">axis2_om_namespace_t* axis2_om_element_declare_namespace(axis2_om_element_t *om_ele, 
axis2_env_t **env, axis2_om_node_t *om_node, axis2_om_namespace_t *om_ns);

axis2_om_namespace_t* axis2_om_element_find_namespace(axis2_om_element_t *om_ele,
axis2_env_t **env, axis2_om_node_t *om_node, axis2_char_t *uri, axis2_char_t *prefix);</pre>

<p>The declare_namespace function is straight forward. It adds a namespace to
namespace declarations section. Note that a namespace declaration that has
already been added will not be added twice. find_namespace is a very handy
method to locate a namespace higher up the tree. It searches for a matching
namespace in its own declarations section and jumps to the parent if it's not
found. The search progresses up the tree until a matching namespace is found
or the root has been reached.</p>

<p>The following simple code segment shows how the namespaces are dealt with
in OM</p>

<div align="left">
<p><b>Code Listing 6</b></p>
</div>
<pre class="code">
axis2_om_namespace_t *ns1 = NULL;
axis2_om_namespace_t *ns2 = NULL;
axis2_om_namespace_t *ns3 = NULL;

axis2_om_node_t *root_node = NULL;
axis2_om_element_t *root_ele = NULL;

axis2_om_node_t *ele1_node = NULL;
axis2_om_element_t *ele1   = NULL;

axis2_om_node_t *text_node = NULL;
axis2_om_text_t *om_text   = NULL;

ns1 = axis2_om_namespace_create(env, "bar", "x");
ns2 = axis2_om_namespace_create(env, "bar1", "y");

root_ele = axis2_om_element_create(env, NULL , "root", ns1, &amp;root_node);
ele1     = axis2_om_element_create(env, root_node, "foo", ns2, &amp;ele1_node);
om_text  = axis2_om_text_create(env, ele1_node, "blah", &amp;text_node);
</pre>

<p>Serilization of the root element produces the following XML</p>
<pre class="xml">
&lt;x:root xmlns:x="bar"&gt;
  &lt;y:foo xmlns:y="bar1"&gt;
        blah
  &lt;/y:foo&gt;
&lt;/x:root&gt;</pre>

<a name="Traversing"> </a><h3>Traversing</h3>

<p>Traversing the OM structure can be done by obtaining an iterator struct. You can either 
call the appropriate function on OM element or create the iterator
manually. OM C offers three iterators to traverse the OM structure. They
are</p>
<ul>
<li>axis2_om_children_iterator_t</li>
<li>axis2_om_child_element_iterator_t</li>
<li>axis2_om_children_qname_iterator_t</li>
</ul>

<p> The Iterator supports the 'OM way' of accessing elements and is more
convenient than a list for sequential access. The following code sample shows
how the children can be accessed. The children can be of type AXIS2_OM_TEXT
or AXIS2_OM_ELEMENT.</p>

<div align="left">
<p><b>Code Listing 7</b></p>

</div>
<pre class="code">axis2_om_children_iterator_t *children_iter = NULL;
children_iter = AXIS2_OM_ELEMENT_GET_CHILDREN(om_ele, env, om_node);
if(NULL != children_iter )
{
    while(AXIS2_OM_CHILDREN_ITERATOR_HAS_NEXT(children_iter, env))
    {
        axis2_om_node_t *node = NULL;
        node = AXIS2_OM_CHILDREN_ITERATOR_NEXT(children_iter, env);
        if(NULL != node)
        {
           if(AXIS2_OM_NODE_GET_NODE_TYPE(node, env) == AXIS2_OM_ELEMENT)
           {
               /** any processing */
           }
        } 

    }
}
</pre>

<p>Apart from this, every axis2_om_node_t struct has links to its siblings.
If more thorough navigation is needed the AXIS2_OM_NODE_GET_NEXT_SIBLING()
and AXIS2_OM_NODE_GET_PREVIOUS_SIBLING() macros can be used. A more selective
set can be chosen by using AXIS2_OM_ELEMENT_XXX_WITH_QNAME() methods. 
The AXIS2_OM_ELEMENT_GET_FIRST_CHILD_WITH_QNAME() method returns the
first child that matches the given axis2_qname_t and
AXIS2_OM_ELEMENT_GET_CHILDREN_WITH_QNAME() returns
axis2_om_children_qname_iterator_t which can be used to travese all the
matching children. The advantage of these iterators is that they won't build
the whole object structure at once, until its required.</p>
<!-- Special section -->

<table width="100%">
  <tbody>
    <tr>
      <td><img src="images/OM005.gif" alt="" width="35" height="57"></td>
      <td class="special-td">All iterator implementations internally stay one
        step ahead of their apparent location to provide the correct value
        for the HAS_NEXT() function . This hidden advancement can build
        elements that are not intended to be built at all.</td>
      <td></td>
    </tr>
  </tbody>
</table>
<!-- End of special section -->

<p>OM can be serialized using AXIS2_OM_NODE_SERIALIZE macro .The
serialization uses a axis2_xml_writer.h API and it writes through
axis2_om_output_t abstract output to write to the output.</p>

<p>Here is an example that shows how to write the output to the console, with
reference to the earlier code sample (Code listing 1 ) that created a SOAP
envelope.</p>

<div align="left">
<p><b>Code Listing 8</b></p>
</div>
<pre class="code">axis2_xml_writer_t *xml_writer = NULL;
axis2_om_output_t *om_output = NULL;
axis2_char_t *buffer = NULL;

..............

xml_writer = axis2_xml_writer_create(env, NULL, 0, 0);
om_output = axis2_om_output_create(env, xml_writer);

AXIS2_SOAP_ENVELOPE_SERIALIZE(envelope, env, om_output);
buffer = AXIS2_XML_WRITER_GET_XML(xml_writer, env);
printf("%s ", buffer);

</pre>
<b>Complete code for the OM based document building and serialization </b>

<p>The following code segment shows how to use the OM for completely building
a document and then serializing it into text pushing the output to the
console. </p>

<div align="left">
<p><b>Code Listing 9</b></p>
</div>
<pre class"code">
test_om.c
FILE *f = NULL;
int read_input_callback(char *buffer, int size, void* ctx)
{
    return fread(buffer, sizeof(char), size, f);
}

int close_input_callback()
{
    return fclose(f);
}

axis2_env_t * create_environment()
{
    axis2_allocator_t *allocator = NULL;
    axis2_env_t *env = NULL;
    axis2_log_t *log = NULL;
    axis2_error_t *error = NULL;
    allocator = axis2_allocator_init(NULL);
    log = axis2_log_create(allocator);
    error = axis2_error_create(allocator);
    env = axis2_env_create_with_error_log(allocator, log, error);
    return env;
}

build_and_serialize_om(axis2_env_t **env)
{
    axis2_om_node_t *root_node = NULL:
    axis2_om_element_t *root_ele = NULL;
    axis2_om_document_t *document = NULL;
    axis2_om_stax_builder_t *om_builder = NULL;
    axis2_xml_reader_t *xml_reader = NULL;
    axis2_xml_writer_t *xml_writer = NULL;
    axis2_om_output_t *om_output = NULL;
    axis2_char_t *buffer = NULL;
    f = fopen("test.xml");
    xml_reader = axis2_xml_reader_create_for_memory(env, read_input_callback,
    close_input_callback, NULL, NULL);
    if(!xml_reader)
        return -1;
    om_builder = axis2_om_stax_builder_create(env, xml_reader);
    if(!om_builder)
    {
        AXIS2_XML_READER_FREE(xml_reader, env);
        return AXIS2_FAILURE;
    }

    document = axis2_om_document_create(env, om_builder);
    if(!document)
    {
        AXIS2_OM_STAX_BUILDER_FREE(om_builder, env);
        return AXIS2_FAILURE;
    }

    root_node = AXIS2_OM_DOCUMENT_GET_ROOT_ELEMENT(document, env);
    if(root_node)
    {
        if(AXIS2_OM_NODE_GET_NODE_TYPE(root_node, env) == AXIS2_OM_ELEMENT)
        {
            root_ele = (axis2_om_element_t*)AXIS2_OM_NODE_GET_DATA_ELEMENT
                                                            (root_node, env);

            if(root_ele)
            {
                printf(" %s" , AXIS2_OM_ELEMENT_GET_DATA_ELEMENT(root_node, env));
            }
        }
    }

    AXIS2_OM_DOCUMENT_BUILD_ALL(document, env);

    xml_writer = axis2_xml_writer_create_for_memory(env, NULL, AXIS2_TRUE, 0);
    om_output = axis2_om_output_create(env, xml_writer);
    AXIS2_OM_NODE_SERIALIZE(node1, env, om_output);
    buffer = AXIS2_XML_WRITER_GET_XML(xml_writer, env);
    printf(" %s ", buffer);

    AXIS2_OM_OUTPUT_FREE(om_output, env);
    AXIS2_OM_STAX_BUILDER_FREE(om_builder, env);
    AXIS2_FREE((*env)-&gt;allocator, buffer);
    return AXIS2_SUCCESS;
}

int main()
{
    int status = AXIS2_SUCCESS;
    axis2_env_t *env = NULL;
    axis2_allocator_t *allocator = NULL;
    env = create_environment();
    status = build_and_serialize_om(&amp;env);
    if(status == AXIS2_FAILURE)
    { 
        printf(" build om failed");
    }
    axis2_env_free(env);
    return 0;
}
</pre>
</body>
</html>
