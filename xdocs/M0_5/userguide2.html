<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=iso-8859-1">
  <title>Axis2 User's Guide</title>
  <meta name="generator"
 content="amaya 9.4, see http://www.w3.org/Amaya/">
</head>
<body dir="ltr" lang="en-US">
<h3><a name="Axis2_User's_Guide">Axis2/C User's Guide</a></h3>
<h4>-Milestone Release 0.5</h4>
<p align="right">Pages: <a href="userguide.html">Content</a>, <a
 href="userguide1.html">1</a>, <b>2</b>, <a href="userguide3.html">3</a></p>
<p><strong>User Feedback</strong>: <a
 href="mailto:axis-user@ws.apache.org">axis-c-user@ws.apache.org</a>
(Prefix
the subject with [Axis2]). To subscribe to mailing list see <a
 href="../mail-lists.html">here.</a></p>
<h2><a name="Web_Service_Clients_Using_Axis2">Web Service Clients Using
Axis2/C</a></h2>
<p>Before we start looking at how to write a service clients, it's
worth going through some background information.</p>
<p>Web Services can be used to provide wide range of functionality to
the
users ranging from simple, less time consuming&nbsp; operations such as
"getStockQuote",&nbsp; to time consuming business services. When we
utilize these Web Services (invoke
using the client applications), we cannot use some simple
generic invocation paradigm that suites all the timing complexities
involved
in the service operations. For example, if we use a single transport
channel
(such as HTTP) to invoke a Web Service with an IN-OUT operation that
take
long time to complete, then most of the time we may end up with
"connection
time outs". On the other hand, if there are simultaneous service
invocations
that&nbsp; we need to perform from a single client application, then
the use of a
"blocking" client API will degrade the performance of the client
application.
Similarly there are various other consequences such as One-Way
transports
that come in to play when we need them. Let's try to analyze some
common
service invocation paradigms.</p>
<p>Many web service engines provide the users with a Blocking and
Non-Blocking client APIs.</p>
<ul>
  <li>
    <p style="margin-bottom: 0in;"><b>Blocking API</b> -Once the
service invocation is called, the client application hangs and only
gets control back when the operation completes, after which client
receives a response or a fault. This is the simplest way of invoking
Web Services and it also suites many business situations.</p>
  </li>
  <li>
    <p><b>Non-Blocking API </b>- This is a callback or polling based
API, hence once a service invocation is called, the client application
immediately gets the control back and the response is retrieved using
the callback object provided. This approach provides the flexibility to
the client application to invoke several Web Services simultaneously
without blocking the operation already invoked.</p>
  </li>
</ul>
<p>Both these mechanisms work in the API level. Let's name the&nbsp;
asynchronous
behavior that we can get using the <strong>Non-Blocking API</strong>
as
<b>API Level Asynchrony.</b></p>
<p>Both these mechanisms use single transport connection to send the
request
and to receive the response. They severely lags the capability of using
two
transport connections for the request and the response (either One-Way
of
Two-Way). So both these mechanisms fail to address the problem of long
running transactions (the transport connection may time-out before the
operation completes). A possible solution would be to use <strong>two
separate transport connections for request and response</strong>. The
asynchronous behavior that we gain using this solution can be called
<b>Transport Level Asynchrony</b>.</p>
<p>By combining API Level Asynchrony &amp; Transport Level Asynchrony
we can
obtain four different invocation patterns for web services as shown in
the
following table.</p>
<a name="table1"></a>
<table border="1" cellpadding="0" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td height="19" width="33%">
      <p><strong>API (Blocking/Non-Blocking)</strong></p>
      </td>
      <td width="33%">
      <p><strong>&nbsp;Dual Transports (Yes/No)</strong></p>
      </td>
      <td width="33%">
      <p><strong>Description</strong></p>
      </td>
    </tr>
    <tr>
      <td height="19" width="33%">
      <p>Blocking</p>
      </td>
      <td width="33%">
      <p>No</p>
      </td>
      <td width="33%">
      <p>Simplest and the familiar invocation pattern</p>
      </td>
    </tr>
    <tr>
      <td height="19" width="33%">
      <p>Non-Blocking</p>
      </td>
      <td width="33%">
      <p>No</p>
      </td>
      <td width="33%">
      <p>Using callbacks or polling</p>
      </td>
    </tr>
    <tr>
      <td height="19" width="33%">
      <p>Blocking</p>
      </td>
      <td width="33%">
      <p>Yes</p>
      </td>
      <td width="33%">
      <p>This is useful when the service operation is IN-OUT in nature
but the transport used is One-Way (e.g. SMTP)</p>
      </td>
    </tr>
    <tr>
      <td height="19" width="33%">
      <p>Non-Blocking</p>
      </td>
      <td width="33%">
      <p>Yes</p>
      </td>
      <td width="33%">
      <p>This is can be used to gain the maximum asynchronous behavior.
No blocking in the API level and also in the transport level</p>
      </td>
    </tr>
  </tbody>
</table>
<p>Axis2/C is designed to provides the user with all these
possibilities to
invoke Web Services.</p>
<p>Currently we have implemented the blocking API only. The other APIs
are being implemented.</p>
<h3><a name="Writing_Web_Service_Clients_using_Axis2's_Primary_APIs">Writing
Web Service Clients Using Axis2's Primary APIs</a></h3>
<h4><a name="EchoBlockingClient">EchoBlockingClient</a></h4>
<p>Let's see how we can write a client to invoke "echoString" operation
of "echo service" using the simplest blocking invocation. The complete
client code with some explanation is shown below.</p>

<pre class="code">
int main()
{
    axis2_om_node_t *node = NULL;
    axis2_om_node_t *ret_node = NULL;

    axis2_status_t status = AXIS2_FAILURE;
    axis2_char_t *client_home = NULL;

    axis2_env_t *env = NULL;
    axis2_error_t *error = NULL;
    axis2_log_t *log = NULL;
    axis2_allocator_t *allocator = NULL;

    axis2_char_t *address = NULL;
    axis2_char_t *wsa_action = NULL;

    axis2_svc_t *svc = NULL;
    axis2_op_t *op = NULL;
    axis2_call_t *call = NULL;

    axis2_msg_ctx_t *response_ctx = NULL;
    axis2_msg_ctx_t *msg_ctx = NULL;

    axis2_mep_client_t *mep_client = NULL;
    axis2_msg_info_headers_t *msg_info_headers = NULL;
    axis2_endpoint_ref_t* endpoint_ref = NULL;
    axis2_conf_t *conf = NULL;
    /* Having created allocator, log and error structs, create environment */
    allocator = axis2_allocator_init (NULL);
    error = axis2_error_create(allocator);
    log = axis2_log_create(allocator, NULL, "addr_echo.log");
    env = axis2_env_create_with_error_log(allocator, error, log);
    env-&gt;log-&gt;level = AXIS2_LOG_LEVEL_TRACE;
    axis2_error_init();


    /* Here the client_home points to the Axis2/C standard deploy folder. The client_home can 
     * be different from this folder. For example, you may have a different folder 
	 *(say, my_client_folder) with its own axis2.xml file. my_client_folder/modules will have the 
     * modules that the client uses
	 */
    client_home = AXIS2_GETENV("AXIS2C_HOME");
    if (!client_home)
        return;

/* end point reference of echo service */
    address = "http://localhost:9090/axis2/services/echo/echo";
    wsa_action = "http://127.0.0.1:9090/axis2/services/echo/echoString";

    /* this builds the SOAP request message using OM API.*/
    node = build_echo_message(&amp;env);

    call = axis2_call_create(&amp;env, NULL, client_home);
    mep_client = AXIS2_CALL_GET_BASE(call, &amp;env);
	
    /* Add the SOAP message to Message Context and get the reference to the Message Context */
    msg_ctx = AXIS2_MEP_CLIENT_PREPARE_SOAP_ENVELOPE(mep_client, &amp;env, node);
	
    /* get the reference to message info headers structure from the message context */
    msg_info_headers = AXIS2_MSG_CTX_GET_MSG_INFO_HEADERS(msg_ctx, &amp;env);
	
    /* create an axis2_endpoint_ref_t struct with ERP assigned */
    endpoint_ref = axis2_endpoint_ref_create(&amp;env, address);

    /* You can set header parameters like this. Have a look at the axis2_msg_info_header.h
     * to find out other macros available
	 */
    AXIS2_MSG_INFO_HEADERS_SET_TO(msg_info_headers, &amp;env, endpoint_ref);
    AXIS2_MSG_INFO_HEADERS_SET_ACTION(msg_info_headers, &amp;env, wsa_action); 

    AXIS2_CALL_SET_TO(call, &amp;env, endpoint_ref);

    /* get the configuration context */
    conf = AXIS2_CONF_CTX_GET_CONF(
                            AXIS2_SVC_CTX_GET_CONF_CTX(
                                AXIS2_MEP_CLIENT_GET_SVC_CTX(mep_client, &amp;env), 
                                &amp;env), 
                                &amp;env);
    /* get the echo service context if it is already loaded to service context*/
    svc = AXIS2_CONF_GET_SVC(conf, &amp;env, "echo");

    if (svc)
    {
        op = AXIS2_SVC_GET_OP_WITH_NAME(svc, &amp;env, "echoString");
        if (op)
        {
            AXIS2_OP_SET_MSG_EXCHANGE_PATTERN(op, &amp;env, AXIS2_MEP_URI_OUT_IN);
        }
    }
    else
    {
		/* echo service is not in the configuration context. We need to create the 
 		 * operation and add it to service context. Then service context into 
		 * configuration context
		 */
        axis2_qname_t *op_qname = NULL;
        axis2_qname_t *svc_qname = axis2_qname_create(&amp;env, "echo", NULL, NULL);
        svc = axis2_svc_create_with_qname(&amp;env, svc_qname);

        op_qname = axis2_qname_create(&amp;env, "echoString", NULL, NULL);
        op = axis2_op_create_with_qname(&amp;env, op_qname);
        AXIS2_OP_SET_MSG_EXCHANGE_PATTERN(op, &amp;env, AXIS2_MEP_URI_OUT_IN);
        AXIS2_SVC_ADD_OP(svc, &amp;env, op);
        AXIS2_CONF_ADD_SVC(conf, &amp;env, svc);
    }

    if (!op)
    {
        printf("ERROR: operation not present in service\n");
        return -1;
    }
	/* Client blocks until the reply message comes. Reply message gets set
	 * to response context.
	 */
    response_ctx = AXIS2_CALL_INVOKE_BLOCKING(call, &amp;env, op, msg_ctx);

    if (response_ctx)
    {
		/* Get the response SOAP message from Response Context */
        axis2_soap_envelope_t *soap_envelope = AXIS2_MSG_CTX_GET_SOAP_ENVELOPE(response_ctx, &amp;env);
        ret_node = AXIS2_SOAP_ENVELOPE_GET_BASE_NODE(soap_envelope, &amp;env);
    }
                                                        
    if(ret_node)
    {
		/* Get the response value from the SOAP message */
        axis2_xml_writer_t *writer = NULL;
        axis2_om_output_t *om_output = NULL;
        axis2_char_t *buffer = NULL;
        
        printf("\necho stub invoke successful!\n");
        writer = axis2_xml_writer_create_for_memory(&amp;env, NULL, AXIS2_TRUE, 0);
        om_output = axis2_om_output_create (&amp;env, writer);
        AXIS2_OM_NODE_SERIALIZE (ret_node, &amp;env, om_output);
        buffer = AXIS2_XML_WRITER_GET_XML(writer, &amp;env);
        printf ("\nReceived OM node in XML : %s\n", buffer); 
        AXIS2_FREE((*env)-&gt;allocator, buffer);
    }
    else
    {
        printf("echo stub invoke failed!\n");
    }
    
    if (call)
    {
        AXIS2_CALL_FREE(call, &amp;env);
    }
    return status;
}

/* build SOAP request message */
axis2_om_node_t* build_echo_message(axis2_env_t **env)
{
    axis2_om_node_t *echo_om_node = NULL;
    axis2_om_element_t *echo_om_ele = NULL;
    axis2_om_node_t* text_om_node = NULL;
    axis2_om_element_t* text_om_ele = NULL;
    axis2_om_namespace_t *ns1 = NULL;

    ns1 = axis2_om_namespace_create (&amp;env, "http://localhost:9090/axis2/services/echo", "ns1");
    echo_om_ele = axis2_om_element_create(&amp;env, NULL, "echoString", ns1, &amp;echo_om_node);
    text_om_ele = axis2_om_element_create(&amp;env, echo_om_node, "text", NULL, &amp;text_om_node);
    AXIS2_OM_ELEMENT_SET_TEXT(text_om_ele, &amp;env, "echo5", text_om_node);

    return text_om_node;
}
</pre>
<h4><a name="Request_SOAP_Message">Request SOAP Message</a></h4>
<pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;soapenv:Envelope xmlns:soapenv="http://www.w3.org/2003/05/soap-envelope"&gt;
      &lt;soapenv:Header xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"&gt;
         &lt;wsa:To&gt;http://localhost:9090/axis2/services/echo/echo&lt;/wsa:To&gt;
         &lt;wsa:Action&gt;http://127.0.0.1:9090/axis2/services/echo/echoString&lt;/wsa:Action&gt;
         &lt;wsa:ReplyTo&gt;
            &lt;wsa:Address&gt;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&lt;/wsa:Address&gt;
         &lt;/wsa:ReplyTo&gt;
         &lt;wsa:ReferenceProperties&gt;&lt;/wsa:ReferenceProperties&gt;
         &lt;wsa:MessageID&gt;325699d4-a438-1da1-3e0b-001125b4e529&lt;/wsa:MessageID&gt;
      &lt;/soapenv:Header&gt;
      &lt;soapenv:Body&gt;
         &lt;ns1:echoString xmlns:ns1="http://localhost:9090/axis2/services/echo"&gt;
            &lt;text&gt;Hello World!&lt;/text&gt;
         &lt;/ns1:echoString&gt;
      &lt;/soapenv:Body&gt;
   &lt;/soapenv:Envelope&gt;
</pre>
<h4><a name="Response_SOAP_Message">Response SOAP Message</a></h4>
<pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;soapenv:Envelope xmlns:soapenv="http://www.w3.org/2003/05/soap-envelope"&gt;
      &lt;soapenv:Header xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"&gt;
         &lt;wsa:To&gt;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&lt;/wsa:To&gt;
         &lt;wsa:Action&gt;http://127.0.0.1:9090/axis2/services/echo/echoString&lt;/wsa:Action&gt;
         &lt;wsa:ReplyTo&gt;
            &lt;wsa:Address&gt;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&lt;/wsa:Address&gt;
         &lt;/wsa:ReplyTo&gt;
         &lt;wsa:ReferenceProperties&gt;&lt;/wsa:ReferenceProperties&gt;
         &lt;wsa:From&gt;
            &lt;wsa:Address&gt;http://localhost:9090/axis2/services/echo/echo&lt;/wsa:Address&gt;
         &lt;/wsa:From&gt;
         &lt;wsa:ReferenceProperties&gt;&lt;/wsa:ReferenceProperties&gt;
         &lt;wsa:MessageID&gt;326a1946-a438-1da1-2b95-001125b4e529&lt;/wsa:MessageID&gt;
         &lt;wsa:RelatesTo wsa:RelationshipType="wsa:Reply"&gt;325699d4-a438-1da1-3e0b-001125b4e529&lt;/wsa:RelatesTo&gt;
      &lt;/soapenv:Header&gt;
      &lt;soapenv:Body&gt;
         &lt;ns1:echoString xmlns:ns1="http://localhost:9090/axis2/services/echo"&gt;
            &lt;text&gt;Hello World!&lt;/text&gt;
         &lt;/ns1:echoString&gt;
      &lt;/soapenv:Body&gt;
   &lt;/soapenv:Envelope&gt;
</pre>
<br>
<p align="right"><a href="userguide1.html"><img
 src="images/arrow_left.gif">
Previous</a> | <a href="userguide3.html">Next <img
 src="images/arrow_right.gif"></a></p>
<p>Pages: <a href="userguide.html">Content</a>, <a
 href="userguide1.html">1</a>, <b>2</b>, <a href="userguide3.html">3</a></p>
</body>
</html>
